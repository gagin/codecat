package main

import (
	"fmt"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"strings"
	"time" // Keep time import

	// Add new dependency

	// Keep existing ones needed
	gitignorelib "github.com/sabhiram/go-gitignore" // Keep for target_only mode
	pflag "github.com/spf13/pflag"
)

const Version = "0.3.0" // Tentative version bump

// FileInfo struct remains the same
type FileInfo struct {
	Path     string
	Size     int64
	IsManual bool
}

// --- Updated Global Variables for Flags ---
var (
	targetDirFlagValue string
	extensions         []string
	manualFiles        []string
	excludePatterns    []string
	// noGitignore removed
	logLevelStr            string
	outputFile             string
	configFileFlag         string
	versionFlag            bool
	gitignoreModeFlagValue string // Added
	noScanFlag             bool   // Added
)

func init() {
	// Define command-line flags using pflag
	pflag.StringVarP(&targetDirFlagValue, "directory", "d", ".", "Target directory to scan (use this OR a positional argument, not both).")
	pflag.StringSliceVarP(&extensions, "extensions", "e", []string{}, "Comma-separated file extensions to include (overrides config).") // Default empty slice, config provides default
	pflag.StringSliceVarP(&manualFiles, "files", "f", []string{}, "Comma-separated specific file paths to include manually.")
	pflag.StringSliceVarP(&excludePatterns, "exclude", "x", []string{}, "Comma-separated glob patterns to exclude (overrides config).") // Default empty slice
	// Removed: pflag.BoolVar(&noGitignore, "no-gitignore",...)
	pflag.StringVar(&logLevelStr, "loglevel", "info", "Set logging verbosity (debug, info, warn, error).")
	pflag.StringVarP(&outputFile, "output", "o", "", "Output file path (writes code to file, summary to stdout).")
	pflag.StringVarP(&configFileFlag, "config", "c", "", "Path to a custom configuration file.")
	pflag.BoolVarP(&versionFlag, "version", "v", false, "Print version and exit.")

	// --- Added/Modified Flags ---
	pflag.StringVar(&gitignoreModeFlagValue, "gitignore-mode", "", "Set gitignore processing mode (off|target_only|recursive). Overrides config.")
	pflag.BoolVarP(&noScanFlag, "no-scan", "n", false, "Skip directory scanning, only process files provided via -f.")

	// Update Usage Message
	pflag.Usage = func() {
		// Keep existing header...
		fmt.Fprintf(os.Stderr, `Usage: %s [target_directory]
   or: %s [flags]

Concatenate source code files into a single output stream or file.

Mode 1: Provide a single [target_directory] positional argument.
        Scans this directory using config file settings (or defaults).
        Cannot be combined with flags like -d, -e, -f, -x, -o, -c, --gitignore-mode, -n.

Mode 2: Use flags only (no positional arguments).
        Use -d to specify directory (defaults to '.'), -e, -f, -x, -o, -c, --gitignore-mode, -n etc.

Output:
  - Default: Code to stdout, Summary/Logs to stderr.
  - With -o <file>: Code to <file>, Summary/Logs to stdout.

Flags:
`, os.Args[0], os.Args[0]) // Keep this line
		pflag.PrintDefaults() // This will now include the new/updated flags
	}
}

// --- Main Execution ---
func main() {
	_ = time.Now() // Keep timestamp line

	pflag.Parse()

	// Handle --version/-v flag
	if versionFlag {
		fmt.Printf("codecat version %s\n", Version)
		os.Exit(0)
	}

	// Setup Logging (remains the same)
	var logLevel slog.Level
	if err := logLevel.UnmarshalText([]byte(logLevelStr)); err != nil {
		fmt.Fprintf(os.Stderr, "Invalid log level %q, defaulting to 'info'.\n", logLevelStr)
		logLevel = slog.LevelInfo
	}
	logOpts := &slog.HandlerOptions{Level: logLevel, AddSource: logLevel <= slog.LevelDebug}
	handler := slog.NewTextHandler(os.Stderr, logOpts)
	slog.SetDefault(slog.New(handler))

	// --- Load Configuration ---
	configFlagPassed := pflag.CommandLine.Changed("config")
	appConfig, loadErr := loadConfig(configFileFlag)
	if loadErr != nil {
		slog.Error("Failed to load configuration.", "error", loadErr)
		if configFlagPassed {
			fmt.Fprintf(os.Stderr, "Error: Could not load specified configuration file '%s': %v\n", configFileFlag, loadErr)
			os.Exit(1)
		} else {
			slog.Warn("Proceeding with default settings due to config load issue.")
			// Ensure appConfig is still the defaultConfig struct here
			appConfig = defaultConfig
		}
	}

	// --- Argument Mode Validation (remains the same) ---
	positionalArgs := pflag.Args()
	finalTargetDirectory := ""
	var conflictingFlagSet bool = false
	var firstConflict string = ""
	// Add new flags to metaFlags if they shouldn't conflict with positional args
	// -n and --gitignore-mode generally *should* conflict if used with positional arg
	metaFlags := map[string]struct{}{
		"help":     {}, // -h
		"loglevel": {},
		"version":  {}, // -v
		"config":   {}, // -c
	}
	pflag.Visit(func(f *pflag.Flag) {
		if _, isMeta := metaFlags[f.Name]; !isMeta {
			conflictingFlagSet = true
			if firstConflict == "" {
				firstConflict = f.Name
			}
		}
	})
	// Rest of positional arg / flag conflict check remains the same...
	if len(positionalArgs) > 1 {
		fmt.Fprintf(os.Stderr, "Refusing execution: Multiple positional arguments provided: %v.\nUse either a single directory argument OR flags.\n", positionalArgs)
		os.Exit(1)
	} else if len(positionalArgs) == 1 {
		if conflictingFlagSet {
			fmt.Fprintf(os.Stderr, "Refusing execution: Cannot mix positional argument '%s' with flag '--%s'.\nUse flags exclusively for complex commands.\n", positionalArgs[0], firstConflict)
			os.Exit(1)
		}
		finalTargetDirectory = positionalArgs[0]
		if finalTargetDirectory == "" {
			finalTargetDirectory = "."
		}
		slog.Debug("Using target directory from positional argument.", "path", finalTargetDirectory)
	} else { // Flags mode or default CWD
		finalTargetDirectory = targetDirFlagValue
		slog.Debug("Using flags mode. Target directory from -d or default.", "path", finalTargetDirectory)
	}

	// --- Validate Final Target Directory (Crucial for NonExistentDir fix) ---
	if finalTargetDirectory == "" {
		slog.Error("Internal configuration error: Target directory is empty.")
		os.Exit(1)
	}
	absTargetDir, err := filepath.Abs(finalTargetDirectory)
	if err != nil {
		slog.Error("Could not determine absolute path for target directory.", "path", finalTargetDirectory, "error", err)
		fmt.Fprintf(os.Stderr, "Error determining absolute path for '%s': %v\n", finalTargetDirectory, err)
		os.Exit(1)
	}
	finalTargetDirectory = absTargetDir // Use absolute path from now on

	// *** CHECK if directory exists and is a directory BEFORE calling generate ***
	// This partly addresses the NonExistentDir issue, but the walk initiator might still fail
	dirInfo, err := os.Stat(finalTargetDirectory)
	if err != nil {
		if os.IsNotExist(err) {
			slog.Error("Target directory does not exist.", "path", finalTargetDirectory)
			fmt.Fprintf(os.Stderr, "Error: Target directory '%s' not found.\n", finalTargetDirectory)
		} else {
			slog.Error("Error accessing target directory info.", "path", finalTargetDirectory, "error", err)
			fmt.Fprintf(os.Stderr, "Error accessing target directory '%s': %v\n", finalTargetDirectory, err)
		}
		// Check if we only have manual files specified and no scan requested
		if noScanFlag && len(manualFiles) > 0 {
			slog.Warn("Target directory not accessible, but --no-scan is used. Processing manual files only.")
			// Proceed, generateConcatenatedCode will handle the walk skip
		} else {
			os.Exit(1) // Exit if scanning is intended or no manual files
		}
	} else if !dirInfo.IsDir() {
		slog.Error("Specified target path is not a directory.", "path", finalTargetDirectory)
		fmt.Fprintf(os.Stderr, "Error: Specified target path '%s' is not a directory.\n", finalTargetDirectory)
		// Check if we only have manual files specified and no scan requested
		if noScanFlag && len(manualFiles) > 0 {
			slog.Warn("Target path is not a directory, but --no-scan is used. Processing manual files only.")
			// Proceed
		} else {
			os.Exit(1)
		}
	}

	// --- Determine final settings ---
	commentMarker := *appConfig.CommentMarker
	headerText := *appConfig.HeaderText
	finalIncludeFileList := appConfig.IncludeFileListInOutput
	finalIncludeEmptyFiles := appConfig.IncludeEmptyFilesInOutput

	// Determine Extensions (apply defaults from config if flag not set)
	var finalExtensionsList []string
	if pflag.CommandLine.Changed("extensions") {
		slog.Debug("Using extensions from command line flag.", "extensions", extensions)
		finalExtensionsList = extensions
	} else {
		slog.Debug("Using extensions from loaded config or default.", "extensions", appConfig.IncludeExtensions)
		finalExtensionsList = appConfig.IncludeExtensions // Use loaded config/defaultConfig value
	}
	finalExtensionsSet := processExtensions(finalExtensionsList)
	slog.Debug("Final extension set prepared", "set_keys", mapsKeys(finalExtensionsSet))

	// Determine Exclude Patterns (apply defaults from config if flag not set)
	var finalExcludePatternsList []string
	if pflag.CommandLine.Changed("exclude") {
		slog.Debug("Using exclude patterns from command line flag.", "patterns", excludePatterns)
		finalExcludePatternsList = excludePatterns
	} else {
		slog.Debug("Using exclude patterns from loaded config or default.", "patterns", appConfig.ExcludePatterns)
		finalExcludePatternsList = appConfig.ExcludePatterns
		if finalExcludePatternsList == nil {
			finalExcludePatternsList = []string{}
		} // Ensure not nil
	}
	slog.Debug("Final exclude patterns", "patterns", finalExcludePatternsList)

	// Determine final GitignoreMode
	var finalGitignoreMode string
	validModes := map[string]struct{}{"off": {}, "target_only": {}, "recursive": {}}
	gitignoreModeFlagUsed := pflag.CommandLine.Changed("gitignore-mode")

	if gitignoreModeFlagUsed {
		modeLower := strings.ToLower(gitignoreModeFlagValue)
		if _, isValid := validModes[modeLower]; isValid {
			finalGitignoreMode = modeLower
			slog.Debug("Using gitignore mode from command line flag.", "mode", finalGitignoreMode)
		} else {
			slog.Error("Invalid value provided for --gitignore-mode flag.", "value", gitignoreModeFlagValue)
			fmt.Fprintf(os.Stderr, "Error: Invalid --gitignore-mode %q. Use 'off', 'target_only', or 'recursive'.\n", gitignoreModeFlagValue)
			os.Exit(1)
		}
	} else {
		// Use config value, falling back to default if config value is invalid or empty
		configModeLower := strings.ToLower(appConfig.GitignoreMode)
		if _, isValid := validModes[configModeLower]; isValid {
			finalGitignoreMode = configModeLower
			slog.Debug("Using gitignore mode from config.", "mode", finalGitignoreMode)
		} else {
			if appConfig.GitignoreMode != "" { // Only warn if config had an invalid value
				slog.Warn("Invalid gitignore_mode in config, using default.", "config_value", appConfig.GitignoreMode, "default", defaultConfig.GitignoreMode)
			} else {
				slog.Debug("Gitignore mode not set in config, using default.", "default", defaultConfig.GitignoreMode)
			}
			finalGitignoreMode = defaultConfig.GitignoreMode // Fallback to default
		}
	}
	slog.Debug("Final gitignore mode determined.", "mode", finalGitignoreMode)

	// --- Input Validation ---
	// Check if scanning is disabled AND no manual files are given
	if noScanFlag && len(manualFiles) == 0 {
		slog.Error("Processing criteria missing. --no-scan used and no manual files (-f) provided. Nothing to process.")
		fmt.Fprintln(os.Stderr, "Error: --no-scan flag used, but no files specified with -f.")
		os.Exit(1)
	}
	// Check if scanning is enabled BUT no extensions are specified
	if !noScanFlag && len(finalExtensionsSet) == 0 && len(manualFiles) == 0 {
		slog.Error("Processing criteria missing. No file extensions specified or configured, and no manual files provided. Nothing to process.")
		fmt.Fprintln(os.Stderr, "Error: No file extensions specified (use -e or config) and no manual files given (-f).")
		os.Exit(1)
	}

	// --- Generate Output ---
	concatenatedOutput, includedFiles, emptyFiles, errorFiles, totalSize, genErr := generateConcatenatedCode(
		finalTargetDirectory,
		finalExtensionsSet,
		manualFiles,
		finalExcludePatternsList,
		finalGitignoreMode,     // Pass the final mode
		finalIncludeFileList,   // Pass flag
		finalIncludeEmptyFiles, // Pass flag
		noScanFlag,             // Pass flag
		headerText,
		commentMarker,
	)
	// *** IMPORTANT: Check genErr here for the NonExistentDir case ***
	if genErr != nil {
		// Log the error from generateConcatenatedCode
		// It might be the "directory not found" error if noScan was false
		slog.Error("Error during file processing.", "error", genErr)

		// Check if it's specifically the "directory not found" type error that main() already checked
		// This prevents duplicate messages if generateConcatenatedCode returns the same os.Stat error
		if !(os.IsNotExist(genErr) && (!noScanFlag || len(manualFiles) == 0)) {
			// Print a general error if it's not the expected NotExist error we might have already handled
			// or if scanning was intended.
			fmt.Fprintf(os.Stderr, "Error during processing: %v\n", genErr)
		}

		// Decide whether to exit. If only manual files were processed successfully
		// despite a dir error + --no-scan, maybe don't exit?
		// For now, exit if any error occurred during generation.
		if !(noScanFlag && len(manualFiles) > 0 && len(includedFiles) > 0) {
			// Exit unless we successfully processed manual files only under --no-scan
			os.Exit(1)
		} else {
			slog.Warn("Proceeding with summary despite directory access error because --no-scan was used and manual files were processed.")
		}
	}

	// --- Determine Output Target and Summary Writer (remains the same) ---
	var codeWriter io.Writer
	var summaryWriter io.Writer
	var outputFileHandle *os.File
	// ... (rest of writer setup logic) ...
	if outputFile != "" {
		file, errCreate := os.Create(outputFile)
		if errCreate != nil {
			slog.Error("Failed to create output file.", "path", outputFile, "error", errCreate)
			fmt.Fprintf(os.Stderr, "Error: Failed to create output file '%s': %v\n", outputFile, errCreate)
			os.Exit(1)
		}
		outputFileHandle = file
		codeWriter = file
		summaryWriter = os.Stdout // Summary to stdout when code goes to file
		slog.Info("Writing concatenated code to file.", "path", outputFile)
	} else {
		codeWriter = os.Stdout    // Code to stdout
		summaryWriter = os.Stderr // Summary to stderr
		slog.Info("Writing concatenated code to stdout.")
	}

	// --- Write Concatenated Code (remains the same) ---
	if concatenatedOutput != "" {
		_, errWrite := io.WriteString(codeWriter, concatenatedOutput)
		if errWrite != nil {
			slog.Error("Failed to write concatenated code.", "error", errWrite)
			fmt.Fprintf(os.Stderr, "Error: Failed to write output: %v\n", errWrite)
			if outputFileHandle != nil {
				_ = outputFileHandle.Close()
			}
			os.Exit(1)
		}
	} else if genErr == nil && len(includedFiles) == 0 && len(manualFiles) == 0 {
		// Only warn if no error occurred and no files were included (and none specified manually)
		slog.Warn("No content generated. Output is empty.")
	}

	if outputFileHandle != nil {
		errClose := outputFileHandle.Close()
		if errClose != nil {
			slog.Error("Failed to close output file.", "path", outputFile, "error", errClose)
			// Don't exit here, just log
		}
	}

	// --- Print Summary (remains the same function call) ---
	printSummaryTree(includedFiles, emptyFiles, errorFiles, totalSize, finalTargetDirectory, summaryWriter)

	slog.Debug("Execution finished.")

	// Exit with error if errors occurred during generation or reported by it
	if genErr != nil || len(errorFiles) > 0 {
		// Avoid exiting again if we already logged warning under --no-scan
		if !(noScanFlag && len(manualFiles) > 0 && len(includedFiles) > 0 && genErr != nil && os.IsNotExist(genErr)) {
			os.Exit(1)
		}
	}
}

// processExtensions, formatBytes, buildTree, TreeNode, printTreeRecursive, printSummaryTree, mapsKeys
// remain the same for now.

// --- GitignoreMatcher (used only for target_only mode now) ---
// Keep this struct and its New/Match methods for now for target_only mode
type GitignoreMatcher struct {
	matcher gitignorelib.IgnoreParser
	root    string
}

func NewGitignoreMatcher(root string) (*GitignoreMatcher, error) {
	// ... (existing implementation) ...
	gitignorePath := filepath.Join(root, ".gitignore")
	var matcher gitignorelib.IgnoreParser
	var err error
	if _, statErr := os.Stat(gitignorePath); os.IsNotExist(statErr) {
		slog.Debug("No .gitignore file found at root.", "directory", root)
		matcher = nil // Explicitly nil
	} else if statErr != nil {
		return nil, fmt.Errorf("error stating .gitignore file %s: %w", gitignorePath, statErr)
	} else {
		matcher, err = gitignorelib.CompileIgnoreFile(gitignorePath)
		if err != nil {
			return nil, fmt.Errorf("error compiling gitignore file %s: %w", gitignorePath, err)
		}
		slog.Debug("Successfully compiled gitignore file.", "path", gitignorePath)
	}
	// Return matcher even if nil (indicates no file found)
	return &GitignoreMatcher{matcher: matcher, root: root}, nil
}
func (g *GitignoreMatcher) Match(relativePath string, isDir bool) bool {
	if g == nil || g.matcher == nil { // Check if matcher itself is nil
		return false
	}
	// The library's Match function should handle the actual matching logic
	return g.matcher.MatchesPath(relativePath)
}
